#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the Common Development
# and Distribution License Version 1.0 (the "License").
#
# You can obtain a copy of the license at
# http://www.opensource.org/licenses/CDDL-1.0.  See the License for the
# specific language governing permissions and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each file and
# include the License file in a prominent location with the name LICENSE.CDDL.
# If applicable, add the following below this CDDL HEADER, with the fields
# enclosed by brackets "[]" replaced with your own identifying information:
#
# Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.
#
# CDDL HEADER END
#

#
# Copyright (c) 2012, Regents of the University of Minnesota.  All rights reserved.
#
# Contributors:
#    Valeriu Smirichinski
#    Ryan S. Elliott
#    Ellad B. Tadmor
#


################################################################################
#
# Open KIM API Standard Definitions
#
# Release: This file is part of the openkim-api.git repository.
#
################################################################################
#
# This file defines the openkim-api standard argument names and their
# properties, the Neighbor Boundary Condition (NBC) methods supported by the
# openKIM API, the list of standard atom/particle types known to KIM, and a set
# of conventions defined by KIM that help to ensure that Models and Tests are
# able to successfully communicate with each other.
#
# The requirements and capabilities of KIM Models and Tests are defined in an
# accompanying plain text document referred to as a "KIM descriptor file".
#
# There are a number of line types that can occur in a KIM descriptor file:
#
#   1) Blank lines
#         These are lines containing only white-space characters.  These lines
#         are silently ignored by the openKIM API.
#
#   2) Comment lines
#         These lines have a `#' as their first (non-white-space) character.
#         All other line types may end with a comment.  The beginning of such a
#         comment is indicated by the first occurrence of the `#' character.
#
#   3) A MODEL/TEST name line
#         Only one such line may occur in a KIM descriptor file and it should
#         be the first line in the descriptor file which is not a comment or a
#         blank line.  The line's first non-white-space characters must be
#         either `MODEL_NAME' or `TEST_NAME' as appropriate, followed by an
#         assignment symbol `:=' (white-space surrounding the assignment symbol
#         is ignored), followed by the (case sensitive) name of the Model or
#         Test.  (See below for a description of valid name strings.)
#
#   4) Units handling line:
#         For Models, a variable `Unit_Handling' specifies whether the Model
#         can adjust its input and output to match a Test (`flexible') or can
#         only work with one set of units (`fixed'). This information is
#         ignored for Tests.  At most one such line may occur in a KIM
#         descriptor file and it should be the second line in the descriptor
#         file which is not a comment or a blank line.  The line's first
#         non-white-space characters must be `Unit_Handling', followed by an
#         assignment symbol `:=' (white-space surrounding the assignment symbol
#         is ignored), followed by either `fixed' or `flexible'.
#
#         Example:
#         Unit_Handling := fixed
#
#   5) Base unit lines:
#         Five lines that describe a set of five base units from which all
#         other units are derived in a consistent way:
#
#         Unit_length      := `A' | `Bohr' | `cm' | `m' | `nm'
#         Unit_energy      := `amu*A^2/(ps)^2' | `erg' | `eV' | `Hartree' |
#                             `J' |`kcal/mol' | kJ/mol'
#         Unit_charge      := `C' | `e' | `statC'
#         Unit_temperature := `K'
#         Unit_time        := `fs' | `ps' | `ns' | `s'
#
#         The list of recognized units above may be extended in the future.
#         (The current list is based on the units used in 8 popular ab initio,
#         MC, MD and lattice dynamics codes: AMBER, CHARMM, DL_POLY, GROMACS,
#         LAMMPS, TOWHEE, VASP.)  As noted above all other units will be
#         derived from these units in a consistent manner.
#
#         Example:
#         Unit_length      := A
#         Unit_energy      := eV
#         Unit_charge      := e
#         Unit_temperature := K
#         Unit_time        := ps
#
#   6) Section lines
#         These lines identify logically distinct sections within the KIM
#         descriptor file.  All lines following a Section line, up to the next
#         Section line or end of the file, will be assigned to the indicated
#         section.  Currently, there are five sections defined by the KIM
#         standard:
#
#            * SUPPORTED_ATOM/PARTICLES_TYPES
#            * CONVENTIONS
#            * MODEL_INPUT
#            * MODEL_OUTPUT
#            * MODEL_PARAMETERS
#
#         These sections may occur in any order within a KIM descriptor file,
#         however the order given above is recommended.  A section line may
#         only occur once within a KIM descriptor file.
#
#   7) Data lines
#         These lines are used to specify the information that a Model (Test)
#         will provide to and require from a Test (Model), as well as the
#         conventions that the Model (Test) uses.  There are currently three
#         types of Data lines:
#
#            * Species Data lines
#               This line type defines the atom/particle types supported by the
#               Test/Model and should only be used within the
#               SUPPORTED_ATOM/PARTICLES_TYPES section of the KIM descriptor
#               file.  The line consists of three white-space separated (case
#               sensitive) strings of maximum KIM_KEY_STRING_LENGTH length.
#               The three strings, in order, are as follows:
#
#                  1) Name: This string gives a unique name to the
#                           atom/particle type.  This name is checked against
#                           the standard list in `standard.kim' (below).
#
#                  2) Type: This must be `spec'.
$
#                  3) code: This is the non-negative integer that the Model
#                           uses internally to identify the atom/particle type.
#                           The special value of `-1' indicates that the Model
#                           will set the code value during the execution of its
#                           `model_init' function.  The value specified by a
#                           Test is ignored.
#
#            * Flag Data lines
#               This line type defines a convention (or flag), that can be used
#               to ensure that Models and Tests are able to work together, and
#               should only be used within the CONVENTIONS section of the KIM
#               descriptor file.  The line consists of two white-space
#               separated (case sensitive) strings of maximum
#               KIM_KEY_STRING_LENGTH length.  The two strings, in order, are
#               as follows:
#
#                  1) Name: This string gives a unique name to the convention.
#                           This name is checked against the standard list in
#                           `standard.kim' (below).
#
#                  2) Type: This must be `flag'.
#
#            * Argument Data lines
#               This line type defines a quantity that is associated with one
#               or more values that must be shared between the Model and Test
#               and should only be used within the MODEL_INPUT, MODEL_OUTPUT,
#               and MODEL_PARAMETERS sections of the KIM descriptor file.
#               These are analogous the the arguments of a function call.  The
#               line consists of five white-space separated (case sensitive)
#               strings of maximum KIM_KEY_STRING_LENGTH length.  The values of
#               these strings are checked against the standard list in
#               `standard.kim' (below) for lines contained in the MODEL_INPUT
#               and MODEL_OUTPUT sections of the KIM descriptor file (but not
#               for lines in the MODEL_PARAMETERS section).  The five strings,
#               in order, are as follows:
#
#                  1) Name: This string gives a unique name to the argument.
#
#                  2) Type: This string defines the data-type of the associated
#                           values.  Currently there are six types:
#
#                           KIM string     C/C++ type      Fortran type
#
#                           `integer'      int             integer
#                           `integer*8'    long long       integer*8
#                           `real'         float           real
#                           `real*8'       double          real*8
#                           `method'       void *          cray pointer
#                           `pointer'      void *          cray pointer
#
#                           The first four are self-explanatory.  The `method'
#                           type allows the Model (Test) to provide pointers to
#                           functions/subroutines that the Test (Model) may use
#                           to perform certain tasks at runtime.  The `pointer'
#                           type is capable of pointing to an arbitrary
#                           location in memory and is a catch-all type that can
#                           be used when none of the other types are
#                           appropriate.
#
#                           NOTE: that in Fortran pointers to memory are
#                                 currently implemented using the cray pointer
#                                 extension which is widely supported by
#                                 Fortran compilers.  In future releases,
#                                 native pointer capabilities in Fortran 2003
#                                 may be adopted.
#
#                  3) Unit: This string defines the physical units of the
#                           values (which must all be the same for all
#                           components of array quantities).
#                           Possible values are:
#
#                              * none
#                              * mass
#                              * length
#                              * time
#                              * energy
#                              * velocity
#                              * force
#                              * torque
#                              * temperature
#                              * pressure
#                              * stress
#                              * dynamic_viscosity
#                              * charge
#                              * dipole
#                              * electric_field
#                              * density
#
#                  4) Shape: This string defines the rank (number of array
#                            dimensions) and extent (size of each dimension)
#                            for the values associated with the argument
#                            quantity.
#
#                            The format of the string is a `[' followed by an
#                            (optional) comma separated list of integers or
#                            character strings, followed by a `]'.
#
#                            If an integer is provided it sets the extent of
#                            the corresponding dimension.  Otherwise one of the
#                            three following strings may be used:
#
#                            `numberOfParticles', `numberParticleTypes', `:'
#
#                            If either of the first two options is present, the
#                            KIM_API_allocate() function will substitute the
#                            value of its `nParticles' or its `nParticleTypes'
#                            arguments, respectively.  If, after this
#                            substitution the extents of EACH dimension is
#                            known, then the KIM_API_allocate() function will
#                            allocate the memory for this argument (otherwise,
#                            if any strings are equal to `:', then memory for
#                            this argument will not be allocated by the
#                            KIM_API_allocate() function and must be allocated
#                            by the Test and registered in the KIM API object
#                            using the KIM_API_set_data() or
#                            KIM_API_setm_data() functions).
#
#                            White-space is not allowed between the `[' and `]'
#                            characters.
#
#                            NOTE that multi-dimensional arrays are defined as
#                            in C with the `fast-index' corresponding to the
#                            last in the list.  No conversion is necessary to
#                            use such an array in Fortan.  The Fortran
#                            programmer simply needs to define the dimensions
#                            of the array in the reverse order.  For example, a
#                            KIM Shape string [10,3] corresponds to a C array
#                            of shape [10][3] and to a Fortran array of shape
#                            (3,10).
#
#                            Providing a few examples is the best way to
#                            clearly define the meaning of the Shape string:
#
#                            * []   - This defines a scalar value (rank=0)
#
#                            * [10] - This defines a vector (rank=1) of 10
#                                     values
#
#                            * [numberOfParticles] - This defines a vector (rank=1)
#                                     of `numberOfParticles' values.  If the
#                                     KIM_API_allocate function is called as
#
#                       KIM_API_allocate(pkim, nParticles, nParticleTypes, kimerr)
#
#                                     it will allocate memory for this
#                                     argument using the value of `nParticles'.
#
#                            * [numberParticleTypes] - This defines a vector
#                                    (rank=1) of `numberParticleTypes' values.  If
#                                    the KIM_API_allocate function is called as
#
#                       KIM_API_allocate(pkim, nParticles, nParticleTypes, kimerr)
#
#                                    it will allocated memory for this argument
#                                    using the value of `nParticleTypes'.
#
#                            * [12,10,5] - This defines a three-dimensional
#                                    array (rank=3) of size 12 by 10 by 5.
#                                    Memory for this array can be allocated by
#                                    the KIM_API_allocate() function.
#
#                            * [numberOfParticles,12,15] - This defines a three-
#                                    dimensional array (rank=3) of size
#                                    `numberOfParticles' by 12 by 15.  Memory for
#                                    this array can be allocated by the
#                                    KIM_API_allocate() function.
#
#                            * [:,12] - This defines a two-dimensional array
#                                    (rank=2) of size (an unspecified length)
#                                    by 12.  In this case, KIM_API_allocate()
#                                    will not allocate any memory for this
#                                    argument.  When the only unknown dimension
#                                    range is the (slowest) first dimension,
#                                    the Test must allocate (and eventually
#                                    free) memory for this argument and use the
#                                    KIM_API_set_data() function in order to
#                                    register the memory location of the values
#                                    for this argument.  When this is done the
#                                    KIM_API_set_data() function will determine
#                                    (and set) the EXTENT of the first
#                                    dimension using the known EXTENTs of the
#                                    remaining dimensions and the `size'
#                                    argument.  If the range of one or more
#                                    dimensions other than the first is
#                                    unknown, then the KIM_API_set_data()
#                                    function does not try to determine the
#                                    unknown EXTENT(s) and will exit with an
#                                    error.  In this type of situation the
#                                    KIM_API_set_shape() function (see below)
#                                    must be used before KIM_API_set_data() is
#                                    called.
#
#                                    NOTE: recall that for standard arguments
#                                    the shape strings are compared with the
#                                    corresponding values in standard.kim (this
#                                    file).  Thus, specifying a constant
#                                    EXTENT, such as the `12' in this example,
#                                    has meaning for the Test/Model matching
#                                    process.  Further, these values are stored
#                                    in the KIM API object (zero is substituted
#                                    wherever a `:' occurs) and can be
#                                    retrieved at run-time (before they are
#                                    overwritten by a call to
#                                    KIM_API_set_shape()).
#
#
#                            * [12,numberOfParticles] - This defines a two-
#                                    dimensional array (rank=2) of size 12 by
#                                    `numberOfParticles'.  Memory for this array
#                                    can be allocated by the KIM_API_allocate()
#                                    function.
#
#                            * [:,:,:,12,:,numberParticleTypes] - This defines
#                                   a six-dimensional array (rank=6).  Memory
#                                   for this array cannot be allocated by the
#                                   KIM_API_allocate() function.  The Test must
#                                   use the KIM_API_set_shape() function to
#                                   register the range of all dimensions (i.e,
#                                   specify the explicit values for the shape).
#                                   Then, the Test must allocate (and
#                                   eventually free) memory for this argument
#                                   and use the KIM_API_set_data() function in
#                                   order to register the memory location of
#                                   the values for this argument.
#
#
#
#                  5) Requirements: This string may be empty or `optional'.  An
#                                   empty string indicates that the argument is
#                                   required to be present by the Test/Model
#                                   (i.e., the Test/Model will read from and/or
#                                   write to the values associated with this
#                                   argument).  Models may use the `optional'
#                                   string.  If this is specified for an input
#                                   argument, it means that the Model can run
#                                   without receiving this argument (but it may
#                                   use it if provided).  If specified for an
#                                   output argument, it means that the argument
#                                   will only be computed if required by the
#                                   Test.
#
################################################################################
#
# The first item in a KIM descriptor file should be the MODEL/TEST name
#
# MODEL/TEST names are case sensitive strings containing only alpha-numeric
# characters and possibly the `_' character.  No other characters are allowed.
#
#
# The MODEL_NAME is either `standard' (used only in this file, which defines
# the KIM standard) or it convention to conform to the following naming
# scheme:
#
#       model_<elements>_<class>_<label>_<KIM-ID>
#
#       where
#
#           <elements> is a alphabetized, concatenated list of entries from the
#                      SUPPORTED_ATOM/PARTICLES_TYPES table given below.  For
#                      example, `AlNi' for a Model able to compute
#                      configurations containing Al and Ni atoms.
#
#           <class> is one of the following strings:
#
#                      * `P'   : pair potential
#                      * `PF'  : pair functional (EAM, Finnis-Sinclair, EMT)
#                      * `3B'  : three-body potential
#                      * `4B'  : four-body potential
#                      * `CF'  : cluster functional (MEAM, ReaxFF, etc.)
#                      * `BOP' : bond-order potential
#
#           <label> is an alphanumeric string uniquely identifying the Model.
#                   It may contain the concatenated list of the Model's
#                   authors, a commonly used name for the potential, the year
#                   it was published, or any other information necessary to
#                   identify it.  The <label> should be kept as short as
#                   possible.
#
#           <KIM-ID> is a unique identifier for the Model generated by
#                    openKIM.org when the Model is uploaded.
#
#                    NOTE: That in this distribution of the KIM API we include
#                          example Models that are not part of the openKIM.org
#                          repository.  Therefore they do not have KIM-IDs and
#                          instead their names start with `ex_' and the last
#                          field provides information on the NBC (Neighbor list
#                          and Boundary Conditions) capabilities of the Model.
#
#       Some examples for MODEL_NAMEs (without the KIM-ID) are
#
#          model_Si_3B_StillingerWeber
#
#          model_Al_PF_ErcolessiAdams
#
#          model_Si_CF_LenoskySadighMEAM
#
#          model_OSi_CF_vanDuinStrachanReaxFF
#
#
# The TEST_NAME is arbitrary at this stage.  It can consist of any combination
# of alphanumeric characters and underscores.  Tests included in the
# openkim.org repository will have additional naming convention requirements.
#
#
# General notes on Test and Model names:
#
#     (1) Model/Test names are limited to alphanumeric characters (letters and
#         numbers) and underscores (`_') to ensure that the final Model/Name
#         name is a valid function name.  Specifically characters such as `-',
#         `:', `&' are not allowed.
#
#     (2) Note that although the handling of Model/Test names is case sensitive
#         within the KIM API and the openKIM.org system, this is not the case
#         when these names are used within Fortran programs since Fortran is
#         not case sensitive.  This will not present a problem normally since
#         each Model/Test will have a unique KIM identifier.  However it is
#         better practice to use <label>s for different Test/Models that differ
#         by more than just the case of the letters.
#
################################################################################

MODEL_NAME := standard

################################################################################
#
# Each Model KIM descriptor file must have a Unit_Handling line.
# There are two options:
#
#    Unit_Handling := fixed      The Model can work only with the units
#                                specified in its descriptor file
#
#    Unit_Handling := flexible   The Model can change the units it
#                                works with when requested
#
# Test KIM descriptor files and this file (standard.kim) should not have a
# Unit_Handling line.
#
################################################################################

################################################################################
#
# Base unit lines:
# Five lines that describe a set of five base units from which all other units
# are derived in a consistent way.  See above for valid values.
#
# All KIM descriptors must have these five lines.  In this file (standard.kim),
# these lines serve to define the "KIM Standard base units".  These values are
# recommended for use as the defaults for all Tests and Models.  However, these
# values are not used as part of the Test/Model matching process.
#
################################################################################

Unit_length      := A
Unit_energy      := eV
Unit_charge      := e
Unit_temperature := K
Unit_time        := ps

################################################################################
#
# The SUPPORTED_ATOM/PARTICLES_TYPES section
#
################################################################################

SUPPORTED_ATOM/PARTICLES_TYPES:

################################################################################
#
# The list of standard KIM atom/particle types
#
# The code listed in 'standard.kim' is the atomic number.  However, this value
# is ignored and only the code value provided by the Model is retained.
#
# In order for a Test and Model to match, a Model must be able to support all
# atom/particle types required by the Test as indicated in its descriptor file.
# If no lines appear in the SUPPORTED_ATOM/PARTICLES_TYPES section for both
# the Test and the Model, then a Test/Model match is possible. This option
# allows for Models and Tests that do not assign any specific physical type to
# their (single) particle type.
#
# Symbol/name               Type         code
#
################################################################################
H                           spec         1              # Hydrogen
He                          spec         2              # Helium
Li                          spec         3              # Lithium
Be                          spec         4              # Beryllium
B                           spec         5              # Boron
C                           spec         6              # Carbon
N                           spec         7              # Nitrogen
O                           spec         8              # Oxygen
F                           spec         9              # Fluorine
Ne                          spec         10             # Neon
Na                          spec         11             # Sodium
Mg                          spec         12             # Magnesium
Al                          spec         13             # Aluminum
Si                          spec         14             # Silicon
P                           spec         15             # Phosphorus
S                           spec         16             # Sulfur
Cl                          spec         17             # Chlorine
Ar                          spec         18             # Argon
K                           spec         19             # Potassium
Ca                          spec         20             # Calcium
Sc                          spec         21             # Scandium
Ti                          spec         22             # Titanium
V                           spec         23             # Vanadium
Cr                          spec         24             # Chromium
Mn                          spec         25             # Manganese
Fe                          spec         26             # Iron
Co                          spec         27             # Cobalt
Ni                          spec         28             # Nickel
Cu                          spec         29             # Copper
Zn                          spec         30             # Zinc
Ga                          spec         31             # Gallium
Ge                          spec         32             # Germanium
As                          spec         33             # Arsenic
Se                          spec         34             # Selenium
Br                          spec         35             # Bromine
Kr                          spec         36             # Krypton
Rb                          spec         37             # Rubidium
Sr                          spec         38             # Strontium
Y                           spec         39             # Yttrium
Zr                          spec         40             # Zirconium
Nb                          spec         41             # Niobium
Mo                          spec         42             # Molybdenum
Tc                          spec         43             # Technetium
Ru                          spec         44             # Ruthenium
Rh                          spec         45             # Rhodium
Pd                          spec         46             # Palladium
Ag                          spec         47             # Silver
Cd                          spec         48             # Cadmium
In                          spec         49             # Indium
Sn                          spec         50             # Tin
Sb                          spec         51             # Antimony
Te                          spec         52             # Tellurium
I                           spec         53             # Iodine
Xe                          spec         54             # Xenon
Cs                          spec         55             # Cesium
Ba                          spec         56             # Barium
La                          spec         57             # Lanthanum
Ce                          spec         58             # Cerium
Pr                          spec         59             # Praseodymium
Nd                          spec         60             # Neodymium
Pm                          spec         61             # Promethium
Sm                          spec         62             # Samarium
Eu                          spec         63             # Europium
Gd                          spec         64             # Gadolinium
Tb                          spec         65             # Terbium
Dy                          spec         66             # Dysprosium
Ho                          spec         67             # Holmium
Er                          spec         68             # Erbium
Tm                          spec         69             # Thulium
Yb                          spec         70             # Ytterbium
Lu                          spec         71             # Lutetium
Hf                          spec         72             # Hafnium
Ta                          spec         73             # Tantalum
W                           spec         74             # Tungsten
Re                          spec         75             # Rhenium
Os                          spec         76             # Osmium
Ir                          spec         77             # Iridium
Pt                          spec         78             # Platinum
Au                          spec         79             # Gold
Hg                          spec         80             # Mercury
Tl                          spec         81             # Thallium
Pb                          spec         82             # Lead
Bi                          spec         83             # Bismuth
Po                          spec         84             # Polonium
At                          spec         85             # Astatine
Rn                          spec         86             # Radon
Fr                          spec         87             # Francium
Ra                          spec         88             # Radium
Ac                          spec         89             # Actinium
Th                          spec         90             # Thorium
Pa                          spec         91             # Protactinium
U                           spec         92             # Uranium
Np                          spec         93             # Neptunium
Pu                          spec         94             # Plutonium
Am                          spec         95             # Americium
Cm                          spec         96             # Curium
Bk                          spec         97             # Berkelium
Cf                          spec         98             # Californium
Es                          spec         99             # Einsteinium
Fm                          spec         100            # Fermium
Md                          spec         101            # Mendelevium
No                          spec         102            # Nobelium
Lr                          spec         103            # Lawrencium
Rf                          spec         104            # Rutherfordium
Db                          spec         105            # Dubnium
Sg                          spec         106            # Seaborgium
Bh                          spec         107            # Bohrium
Hs                          spec         108            # Hassium
Mt                          spec         109            # Meitnerium
Ds                          spec         110            # Darmstadtium
Rg                          spec         111            # Roentgenium
Cn                          spec         112            # Copernicium
Uut                         spec         113            # Ununtrium
Uuq                         spec         114            # Ununquadium
Uup                         spec         115            # Ununpentium
Uuh                         spec         116            # Ununhexium
Uus                         spec         117            # Ununseptium
Uuo                         spec         118            # Ununoctium
electron                    spec         200            # electrons
user01                      spec         201            # user defined
user02                      spec         202            # user defined
user03                      spec         203            # user defined
user04                      spec         204            # user defined
user05                      spec         205            # user defined
user06                      spec         206            # user defined
user07                      spec         207            # user defined
user08                      spec         208            # user defined
user09                      spec         209            # user defined
user10                      spec         210            # user defined
user11                      spec         211            # user defined
user12                      spec         212            # user defined
user13                      spec         213            # user defined
user14                      spec         214            # user defined
user15                      spec         215            # user defined
user16                      spec         216            # user defined
user17                      spec         217            # user defined
user18                      spec         218            # user defined
user19                      spec         219            # user defined
User20                      spec         220            # user defined

################################################################################
#
# The CONVENTIONS section
#
# This section includes information on general operation conventions of a
# Test/Model
#
# Each line in the CONVENTIONS section consists of a `Name' and `Type'.
#
################################################################################

CONVENTIONS:

################################################################################
#
# In an actual KIM descriptor (.kim) file, exactly ONE of the following two
# lines must be included.  This information is used by neighbor lists and the
# process_d?Edr? mechanism.
#
################################################################################
ZeroBasedLists              flag        # Presence of this line indicates that
                                        # indexes for particles are from 0 to
                                        # numberOfParticles-1 (C-style)

OneBasedLists               flag        # Presence of this line indicates that
                                        # indexes for particles are from 1 to
                                        # numberOfParticles (Fortran-style)

################################################################################
#
# The following three lines are related to the locator/iterator neighbor list
# access mode.  These ensure that a Model will not try to use an access mode
# that is not supported by the routines provided by the Test.
#
# If Neigh_IterAccess and Neigh_LocaAccess are both in the file, it means that
# the Model/Test can work with either mode but does not require both.
#
# If Neigh_BothAccess is in the file, it means that the Model (Test) requires
# (provides) both access modes in order to function.
#
# It is an error to include Neigh_BothAccess with either of the other two
# options in a KIM descriptor (.kim) file.
#
################################################################################
Neigh_IterAccess            flag        # works with iterator mode

Neigh_LocaAccess            flag        # works with locator mode

Neigh_BothAccess            flag        # need both locator and iterator modes


################################################################################
#
# Neighbor list and Boundary Condition (NBC) methods
#
# These are the KIM standard methods for dealing with neighbor lists and
# boundary conditions.
#
################################################################################

# In the CLUSTER method, the Model receives the number of particles and
# coordinates without additional information (such as neighbor lists or other
# boundary condition specifiers) and computes requested quantities under the
# assumption that the particles form an isolated cluster. For example, if
# energy and forces are requested, it will compute the total energy of all the
# particles based on the supplied particle coordinates and the derivative of
# the total energy with respect to the positions of the particles.
#
CLUSTER                     flag        # The Model needs only coordinates to
                                        # compute; a neighbor list is not used.

# In the NEIGH_PURE methods (NEIGH_PURE_H and NEIGH_PURE_F), the Model receives
# the number of particles, coordinates and a full or half neighbor list. The
# neighbor list defines the environment of each particle, from which the
# particles's energy is defined.  In the case of a half list, the value of the
# argument `numberContributingParticles' indicates that the first
# `numberContributingParticles' contribute their energy to the total and the
# remaining particles do not contribute to the energy (they are "ghost"
# particles).  When `numberContributingParticles' is equal to `numberParticles'
# the half list is called "symmetric", otherwise it is called "unsymmetric."
# In the case of a full list, any particle that has one or more neighbors
# contributes its energy to the total and those particles with zero neighbors
# do not contribute to the total energy.  The model computes the requested
# quantities using the supplied information.  For example, if energy and forces
# are requested, it will compute the total energy of all the particles based on
# their neighbor lists and the derivative of the total energy with respect to
# the positions of the particles.  This method can be used with codes that use
# ghost particles to apply boundary conditions.  The ghost particles are
# treated as regular particles by the Model, and it is up to the calling code
# to discard some information such as the forces on the ghost particles and to
# compute the appropriate total energy from per-particle energies of the
# physical particles, or to use a modified neighbor list to obtain the desired
# values.
#
NEIGH_PURE_H                flag        # This is the Pure Half neighbor list
                                        # method.  The model needs
                                        # `coordinates', a half neighbor list
                                        # (with data stored in the
                                        # `neighObject' argument), the
                                        # `numberContributingParticles', and
                                        # the `get_neigh' method supplied by
                                        # the Test.

NEIGH_PURE_F                flag        # This is the Pure Full neighbor list
                                        # method.  The model needs
                                        # `coordinates', a full neighbor list
                                        # (with data stored in the
                                        # `neighObject' argument), and the
                                        # `get_neigh' method supplied by the
                                        # Test.

# In the NEIGH_RVEC_F method, the Model receives the number of particles and
# coordinates, a full neighbor list and the relative position vectors r_ij
# (r_ij = x_j-x_i). The neighbor list and Rij vectors define the environment of
# each particle, from which the particles's energy is defined. The Model
# computes the requested quantities using the supplied information. For
# example, if energy and forces are requested, it will compute the total energy
# of all the particles based on their neighbor lists and relative position
# vectors and the derivative of the total energy with respect to the positions
# of the particles. This method enables the application of general periodic
# boundary conditions, including multiple images.  (This approach can fail with
# half neighbor lists and therefore the _H variant of the method does not
# exist.)  A possible future extension to this method is to allow the Test to
# provide a ForceTransformation() function for each neighbor, which would
# enable the application of complex boundary conditions such as torsion and
# objective boundary conditions.
#
NEIGH_RVEC_F                flag        # This is the Relative Vector Boundary
                                        # Condition Full neighbor list method.
                                        # The Model needs `coordinates' and a
                                        # full neighbor list (with data stored
                                        # in the `neighObject' argument), and
                                        # the `get_neigh' method supplied by
                                        # the Test.  The `neighObject' argument
                                        # must also contain the relative
                                        # position vectors (RVEC) (which are
                                        # returned by the `get_neigh'
                                        # function).

# In the MI_OPBC methods (MI_OPBC_H and MI_OPBC_F), the Model receives the
# number of particles and coordinates, the side lengths for the periodic
# orthogonal box and a neighbor list.  It assumes all particles lie inside the
# periodic box.  Side lengths of the box must be at least twice the cutoff
# range.  This method computes the requested quantities under the assumption
# that the particles are subjected to the minimum image, orthogonal, periodic
# boundary conditions.
#
MI_OPBC_H                   flag        # This is the Minimum Image Orthogonal
                                        # Periodic Boundary Condition Half
                                        # neighbor list method.  The Model
                                        # needs `coordinates', a half neighbor
                                        # list (with data stored in the
                                        # `neighObject' argument),
                                        # `numberContributingParticles', the
                                        # `get_neigh' method supplied by the
                                        # Test, and the `boxSideLengths'
                                        # argument (which specifies the three
                                        # side-lengths of the orthogonal
                                        # simulation box).

MI_OPBC_F                   flag        # This is the Minimum Image Orthogonal
                                        # Periodic Boundary Condition Full
                                        # neighbor list method.  The Model
                                        # needs `coordinates', a full neighbor
                                        # list (with data stored in the
                                        # `neighObject' argument), the
                                        # `get_neigh' method supplied by the
                                        # Test, and the `boxSideLengths'
                                        # argument (which specifies the three
                                        # side-lengths of the orthogonal
                                        # simulation box).


################################################################################
#
# The MODEL_INPUT section
#
################################################################################

MODEL_INPUT:

################################################################################
#
# Every data line in the input section of a KIM descriptor file of a Test and
# Model consists of five fields:
#
# Name
# Type
# Unit
# Shape
# Requirements
#
# Each of these lines must exactly match with one of the standard definitions
# given below except for the field `Requirements'.  The `Requirements' field is
# only meaningful in a Model KIM descriptor file as described above.  It is
# therefore left blank in the standard definitions below.
#
################################################################################

################################################################################
#
# numberOfParticles : The number of particles in the configuration passed
#                     between the Model and Test.
#
# Particles are always numbered sequentially starting from 0 or 1 depending on
# the ZeroBasedLists/OneBasedLists convention setting.  This argument is
# required for all Models and Tests.  A Test must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit                Shape
#
numberOfParticles           integer      none                []

################################################################################
#
# numberContributingParticles: The number of particles that contribute to the
#                              energy (required for all half neighbor lists).
#
# This argument allows a half neighbor list to be "unsymmetric."  Only the
# first `numberContributingParticles' particles will contribute their energy to
# the total.  If supported, a Test must allocate memory for this argument and
# register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
numberContributingParticles integer      none               []

################################################################################
#
# numberParticleTypes: The number of types of atoms/particles contained in the
#                      configuration passed between the Model and Test.
#
# This argument is required for any Model/Test that specifies one or more
# atom/particle types in the SUPPORTED_ATOM/PARTICLE_TYPES section.  If
# supported, a Test must allocate memory for this argument and register it in
# the KIM API object (via KIM_API_allocate() or KIM_API_set_data()) before the
# KIM_API_model_compute() function is called.  The Test is free to change this
# pointer at any time.
#
# Name                      Type         Unit              Shape
#
numberParticleTypes         integer      none              []

################################################################################
#
# particleTypes : A vector of integers indicating the type of each particle in
#                 the configuration passed between the Model and Test.
#
# The values in this vector must correspond to the `code' specified in the
# Model's KIM descriptor file.  This argument is required for any Model/Test
# that specifies one or more atom/particle types in the
# SUPPORTED_ATOM/PARTICLE_TYPES section.  If supported, a Test must allocate
# memory for this argument and register it in the KIM API object (via
# KIM_API_allocate() or KIM_API_set_data()) before the KIM_API_model_compute()
# function is called.  The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleTypes               integer      none               [numberOfParticles]

################################################################################
#
# coordinates : An array of floating-point numbers specifying the spatial
#               location of each of the numberOfParticles atom/particle in the
#               configuration passed between the Model and Test.
#
# This argument is required for all Models and Tests.  A Test must allocate
# memory for this argument and register it in the KIM API object (via
# KIM_API_allocate() or KIM_API_set_data()) before the KIM_API_model_compute()
# function is called.  The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
coordinates                 real*8       length             [numberOfParticles,3]

################################################################################
#
# particleCharge : An array of floating-point numbers specifying the charge of
#                  each particle.
#
# If supported, a Test must allocate memory for this argument and register it
# in the KIM API object (via KIM_API_allocate() or KIM_API_set_data()) before
# the KIM_API_model_compute() function is called.  The Test is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleCharge              real*8       charge             [numberOfParticles]

################################################################################
#
# particleSize : An array of floating-point numbers specifying the size of each
#                particle.
#
# If supported, a Test must allocate memory for this argument and register it
# in the KIM API object (via KIM_API_allocate() or KIM_API_set_data()) before
# the KIM_API_model_compute() function is called.  The Test is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleSize                real*8       length             [numberOfParticles]

################################################################################
#
# get_neigh : A pointer to the neighbor list access function that is provided
#             by the Test.
#
# This argument is required for Models/Tests that support any NBCs other than
# CLUSTER. It is recommended that for Models this argument be optional to
# ensure that a Model is compatible with the widest possible set of Tests.
#
# If supported, a Test must allocate memory for this argument and register it
# in the KIM API object (via KIM_API_allocate() or KIM_API_set_data()) before
# the KIM_API_model_compute() function is called.  The Test is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
get_neigh                   method       none               []

################################################################################
#
# process_dEdr : A pointer to a function that can compute arbitrary linear
#                combinations of the first derivative of the Model's energy
#                with respect to the distances between particles.
#
# During the Model's compute loop, this function will be called multiple times
# with a scalar value representing a contribution to the derivative of the
# energy with respect to a pair distance.  The Test can use this information to
# compute, via the chain-rule, many properties.  Examples include forces, the
# virial and other thermodynamic tensions.  If supported, a Test must allocate
# memory for this argument and register it in the KIM API object (via
# KIM_API_allocate() or KIM_API_set_data()) before the KIM_API_model_compute()
# function is called.  The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
process_dEdr                method       none               []

################################################################################
#
# process_d2Edr2 : A pointer to a function that can compute arbitrary linear
#                  combinations of the second derivative of the Model's energy
#                  with respect to the distances between particles.
#
# The function will be called multiple times with a scalar value representing a
# contribution to the second derivative of the energy with respect to two pair
# distances.  The Test can use this information (often in conjunction with
# process_dEdr) to compute, via the chain-rule, many properties.  An example is
# the hessian.  If supported, a Test must allocate memory for this argument and
# register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.

#
# Name                      Type         Unit               Shape
#
process_d2Edr2              method       none               []

################################################################################
#
# neighObject : A pointer to the data for the neighbor list that is provided by
#               the Test.
#
# This argument is required for Models/Tests that support the following any NBC
# other than CLUSTER.  If supported, a Test must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
neighObject                 pointer      none               []

################################################################################
#
# boxSideLengths : A vector of three floating-point numbers indicating the side
#                  lengths of the minimum-image periodic orthogonal box.
#
# This argument is required for Models/Tests that support the following NBCs:
# MI_OPBC_H and MI_OPBC_F.  If supported, a Test must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
boxSideLengths              real*8       length             [3]

################################################################################
#
# temperature : A scalar specifying the system temperature.
#
# This argument is required for a special class of temperature-dependent models.
#
# Name                      Type         Unit               Shape
#
temperature                 real*8       temperature        []


################################################################################
#
# The MODEL_OUTPUT section
#
################################################################################

MODEL_OUTPUT:

################################################################################
#
# The data lines in the output section of the KIM descriptor file of a Test and
# Model consist of five fields and must satisfy the same restrictions as the
# lines in the input section as explained above (following the MODEL_INPUT
# section line).
#
################################################################################

################################################################################
#
# compute : A pointer to the Model's compute function which given the input
#           defined in the MODEL_INPUT section will calculate quantities
#           described in the MODEL_OUTPUT section.
#
# This argument is required for all Models and Tests.  A Model must register a
# pointer to its `compute' function during the execution of
# KIM_API_model_init().  The Model is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
compute                     method       none               []

################################################################################
#
# reinit : A pointer to the Model's reinit function (called to reinitialize a
#          Model following a change to its parameters by a Test).
#
# This argument is required if a Models publishes its parameters.  However, the
# argument should be included, as optional, by all Models to ensure maximum
# compatibility with Tests (who should only include the argument if they use
# it).  If supported, a Model must register a pointer to its `reinit' function
# during the execution of KIM_API_model_init().  The Model is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
reinit                      method       none               []

################################################################################
#
# destroy : A pointer to the Model's destroy function (called by a Test prior to
#           a KIM_API_free() call to allow the Model to perform any necessary
#           clean-up operations).
#
# This argument is required if a Model publishes its parameters (so that it can
# free the memory that it allocated for its parameters in its init function).
# However, the argument should be included by all Models (as optional, at
# least) to ensure maximum compatibility with Tests (who should only include
# the argument if they use it).  If supported, a Model must register a pointer
# to its `destroy' function during the execution of KIM_API_model_init().  The
# Model is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
destroy                     method       none               []

################################################################################
#
# cutoff : A floating-point number indicating the Model's range of interactions
#          (i.e. its cutoff radius).
#
# This argument is required for all Models/Tests.  This value should not be
# modified by the Test.  A Test must allocate memory for this argument and
# register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_init() function is called.  The
# Test is free to change this pointer at any time.  However, when such a change
# occurs, the Test must ensure that the value stored in the memory pointed to
# is preserved.  If the Model allows for its cutoff distance to be changed it
# will provide the parameter PARAM_FREE_cutoff (see below) which can be
# changed.  Once the PARAM_FREE_cutoff parameter has been changed and the
# Model's reinit function called, the Model must update the value of `cutoff'.
#
# Name                      Type         Unit               Shape
#
cutoff                      real*8       length             []

################################################################################
#
# energy : A floating-point number corresponding to the total energy of the
#          configuration of particles passed between the Model and Test.
#
# This argument should, ideally, be optional to ensure maximum Model/Test
# compatibility.  If supported, a Test must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
energy                      real*8       energy             []

################################################################################
#
# forces : An array of floating-point numbers corresponding to the total force
#          acting each atom/particle in the configuration of particles passed
#          between the Model and Test.
#
# This argument should be optional to ensure maximum Model/Test compatibility.
# If supported, a Test must allocate memory for this argument and register it
# in the KIM API object (via KIM_API_allocate() or KIM_API_set_data()) before
# the KIM_API_model_compute() function is called.  The Test is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
forces                      real*8       force              [numberOfParticles,3]

################################################################################
#
# particleEnergy : A vector of floating-point numbers corresponding to the
#                 energy of each particle in the configuration passed between
#                 the Model and Test.
#
# This argument should, ideally, be optional to ensure maximum Model/Test
# compatibility.  If supported, a Test must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleEnergy              real*8       energy             [numberOfParticles]

################################################################################
#
# virial : A symmetric second-order tensor corresponding to the total virial for
#          the configuration of particles passed between the Model and Test.
#
# The components of this 3 x 3 symmetric tensor are stored in a compact vector
# form with 6 components in accordance with the Voigt convention:
#
# {11,22,33,23,13,12} or {xx,yy,zz,yz,xz,xy}
#
# A Model may support the virial computation by having the KIM API compute it
# via the default process_dEdr mechanism.  (In this case the Model will list
# the `process_dEdr' argument in its descriptor file and call the
# KIM_API_process_dEdr() function in its compute loop.  The Test should list
# `virial' in its descriptor file.)
#
# This argument should, ideally, be optional to ensure maximum Model/Test
# compatibility.  If supported, a Test must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
virial                      real*8       energy             [6]

################################################################################
#
# particleVirial : A symmetric second-order tensor corresponding to the per
#                  particle virial for the configuration of particles passed
#                  between the Model and Test.
#
# The components of each 3 x 3 symmetric tensor are stored in a compact vector
# form with 6 components in accordance with the Voigt convention:
#
# {11,22,33,23,13,12} or {xx,yy,zz,yz,xz,xy}
#
# A Model may support the virial computation by having the KIM API compute it
# via the default process_dEdr mechanism.  (In this case the Model will list
# the `process_dEdr' argument in its descriptor file and call the
# KIM_API_process_dEdr() function in its compute loop.  The Test should list
# `particleVirial' in its descriptor file.)
#
# This argument should, ideally, be optional to ensure maximum Model/Test
# compatibility.  If supported, a Test must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleVirial              real*8       energy             [numberOfParticles,6]

################################################################################
#
# hessian : A matrix of second derivatives of the Model's energy.  For
#           computational efficiency the matrix is stored as a
#           numberOfParticles by numberOfParticles array of 3 by 3 matrices.
#
# A Model may support the hessian computation by having the KIM API compute it
# via the default process_dEdr and process_dE2dr2 mechanisms.  (In this case
# the Model will list the `process_dEdr' and `process_dE2dr2' arguments in its
# descriptor file and call the KIM_API_process_dEdr() and
# KIM_API_process_d2Edr2() functions in its compute loop.  The Test should list
# `hessian' in its descriptor file.)  In the future a sparse array format may
# be introduces in order to reduce memory usage for this and other similar
# arguments.
#
# This argument should, ideally, be optional to ensure maximum Model/Test
# compatibility.  If supported, a Test must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Test is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
hessian                     real*8       pressure           [numberOfParticles,numberOfParticles,3,3]

################################################################################
#
# The MODEL_PARAMETERS section
#
################################################################################

MODEL_PARAMETERS:

################################################################################
#
# Two types of model parameters are allowed (the Unit and Requirements strings
# are ignored for MODEL_PARAMETER lines):
#
# 1) PARAM_FIXED_<label> : A parameter that should not be changed by the Test.
#                          A `fixed parameter' may also be used by the Model
#                          for persistent storage between calls to the Model's
#                          compute routine and/or as local memory space to
#                          avoid the overhead of memory allocation/deallocation
#                          during each execution of the compute routine.
#                          However, this storage should not depend on the
#                          content provided by the Test.  For persistent
#                          storage of this type the Model Buffer should be
#                          used.
#
# 2) PARAM_FREE_<label>  : A parameter that may be changed by the Test (which
#                          must then call the KIM_API_model_reinit() function
#                          to inform the Model that its parameters have
#                          changed).
#
# In the above <label> is an arbitrary string of alphanumeric characters and
# the underscore (`_') character.
#
#
# IMPORTANT NOTE: It is important to stress that a Model may not store data in
# static memory since it may be called with different KIM API objects.  Any
# information that should persist between calls must be stored in the KIM API
# object.  Fixed parameters may be used for this purpose as noted above.
#
#
# Memory for PARAM_* arguments is **NOT** allocated in any case by the KIM API
# (and should not be allocated by a Test).  The Model is responsible for
# allocating (in the model_init function) and freeing (in the model_destroy
# function) all memory for its parameters.
#
# Examples
#
# Name                      Type         Unit               Shape
#
# PARAM_FREE_Sigma          real*8       length             []
# PARAM_FREE_Epsilon        real*8       energy             []
# PARAM_FIXED_LJshift       real*8       energy             []
#
# In this example `PARAM_FIXED_LJshift' is a shift that brings the
# Lennard-Jones potential to zero at the defined cutoff radius.
# If the Sigma or Epsilon parameters are changed by the Test,
# `PARAM_FIXED_LJshift' will be recomputed during required call to
# model_reinit.
#
#
################################################################################

################################################################################
#
# PARAM_FREE_cutoff : A standard free parameter that is used to store the
#                     cutoff radius of the Model.  This parameter allows a Test
#                     to modify a Model by changing its cutoff radius as
#                     described above.
#
# NOTE: Currently this is the only standard parameter defined by the KIM API.
#
#
# Name                      Type         Unit               Shape
#
PARAM_FREE_cutoff           real*8       length             []

# END of standard.kim file
